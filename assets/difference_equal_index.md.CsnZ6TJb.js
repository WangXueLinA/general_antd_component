import{$ as e,S as l,X as d,aL as a}from"./chunks/framework.BrhAmV34.js";const y=JSON.parse('{"title":"react/vue相同点","description":"","frontmatter":{},"headers":[],"relativePath":"difference/equal/index.md","filePath":"difference/equal/index.md","lastUpdated":1759130977000}'),n={name:"difference/equal/index.md"};function i(r,t,s,c,x,g){return d(),l("div",null,t[0]||(t[0]=[a('<h1 id="react-vue相同点" tabindex="-1">react/vue相同点 <a class="header-anchor" href="#react-vue相同点" aria-label="Permalink to &quot;react/vue相同点&quot;">​</a></h1><ul><li>都使用Virtural DOM</li><li>都使用组件化思想，流程基本一致</li><li>都遵循数据驱动视图，推崇单向数据流</li><li>都有成熟的社区，都支持服务端渲染</li></ul><p>Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法。不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数，render函数执行返回VNode（虚拟DOM的数据结构，本质上是棵树）。当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。</p><p>Vue和React通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode diff -&gt; diff算法对比，并真正去更新真实DOM。</p><p>核心还是Virtual DOM，为什么Vue和React都选择Virtual DOM（React首创VDOM，Vue2.0开始引入VDOM）？主要有以下几点：</p><p>减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom，同时也使得数据驱动视图 为函数式UI编程提供可能（React核心思想） 可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:center;">React</th><th style="text-align:center;">Vue</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">组件化</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">将 UI 拆分为独立组件</td></tr><tr><td style="text-align:left;">虚拟 DOM</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">提高渲染性能</td></tr><tr><td style="text-align:left;">数据驱动</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">数据变化自动更新视图</td></tr><tr><td style="text-align:left;">响应式</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">状态更新机制</td></tr><tr><td style="text-align:left;">生命周期</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">组件各阶段钩子函数</td></tr><tr><td style="text-align:left;">条件 / 列表渲染</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">动态生成 DOM</td></tr><tr><td style="text-align:left;">JSX / 模板</td><td style="text-align:center;">✅（JSX）</td><td style="text-align:center;">✅（模板 / JSX）</td><td style="text-align:left;">UI 描述方式</td></tr><tr><td style="text-align:left;">生态系统</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">完善的配套工具</td></tr><tr><td style="text-align:left;">跨平台</td><td style="text-align:center;">✅（React Native）</td><td style="text-align:center;">✅（Vue Native/Weex/uni-app）</td><td style="text-align:left;">多端运行能力</td></tr></tbody></table>',7)]))}const o=e(n,[["render",i]]);export{y as __pageData,o as default};
