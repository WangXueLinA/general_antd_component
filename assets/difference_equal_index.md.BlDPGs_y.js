import{$ as e,S as d,X as a,aL as l}from"./chunks/framework.BrhAmV34.js";const x=JSON.parse('{"title":"react/vue相同点","description":"","frontmatter":{},"headers":[],"relativePath":"difference/equal/index.md","filePath":"difference/equal/index.md","lastUpdated":1761583402000}'),r={name:"difference/equal/index.md"};function o(c,t,n,i,s,f){return a(),d("div",null,t[0]||(t[0]=[l('<h1 id="react-vue相同点" tabindex="-1">react/vue相同点 <a class="header-anchor" href="#react-vue相同点" aria-label="Permalink to &quot;react/vue相同点&quot;">​</a></h1><ul><li>都使用Virtural DOM</li><li>都使用组件化思想，流程基本一致</li><li>都遵循数据驱动视图，推崇单向数据流</li><li>都有成熟的社区，都支持服务端渲染</li></ul><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h2><p>Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法。不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数，render函数执行返回VNode（虚拟DOM的数据结构，本质上是棵树）。当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。</p><p>Vue和React通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode diff -&gt; diff算法对比，并真正去更新真实DOM。</p><h2 id="为什么选择virtual-dom" tabindex="-1">为什么选择Virtual DOM <a class="header-anchor" href="#为什么选择virtual-dom" aria-label="Permalink to &quot;为什么选择Virtual DOM&quot;">​</a></h2><p>为什么Vue和React都选择Virtual DOM（React首创VDOM，Vue2.0开始引入VDOM）？主要有以下几点：</p><ol><li>减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom，同时也使得数据驱动视图</li></ol><p>由于vue跟react的框架他的颗粒的只能精确到组件，也就是说vue跟react里面，数据变化了，更新的整个组件， 如果组件里面有1000个真实的dom的话，只需要更新一个真实的dom，如果在组件内部1000个真实的dom又重新生成了的代价太大， 因此选择一种比较小的代价，生成虚拟dom，然后通过diff算法去精准的对比真实的dom哪里需要更新</p><ol start="2"><li>可以跨平台。在设计框架的时候，他是希望移植到其他不仅仅是浏览器的环境中的，不如像小程序，app等平台，所以这时候就不能绑定真实dom，因为真实dom只有在浏览器环境里才有，别的环境里面没有，所有他用js对象来模拟dom，js对象属于ES范畴，只要环境支持ES，那么就一定支持js对象的，然后到真实的运行环境中进行不用的渲染，移动端就渲染成原生组件，浏览器就渲染成真实的dom</li></ol><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:center;">React</th><th style="text-align:center;">Vue</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">组件化</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">将 UI 拆分为独立组件</td></tr><tr><td style="text-align:left;">虚拟 DOM</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">提高渲染性能</td></tr><tr><td style="text-align:left;">数据驱动</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">数据变化自动更新视图</td></tr><tr><td style="text-align:left;">响应式</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">状态更新机制</td></tr><tr><td style="text-align:left;">生命周期</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">组件各阶段钩子函数</td></tr><tr><td style="text-align:left;">条件 / 列表渲染</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">动态生成 DOM</td></tr><tr><td style="text-align:left;">JSX / 模板</td><td style="text-align:center;">✅（JSX）</td><td style="text-align:center;">✅（模板 / JSX）</td><td style="text-align:left;">UI 描述方式</td></tr><tr><td style="text-align:left;">生态系统</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:left;">完善的配套工具</td></tr><tr><td style="text-align:left;">跨平台</td><td style="text-align:center;">✅（React Native）</td><td style="text-align:center;">✅（Vue Native/Weex/uni-app）</td><td style="text-align:left;">多端运行能力</td></tr></tbody></table><h2 id="相似api" tabindex="-1">相似api <a class="header-anchor" href="#相似api" aria-label="Permalink to &quot;相似api&quot;">​</a></h2><table tabindex="0"><thead><tr><th>React Hook</th><th>Vue 3 Composition API</th><th>功能描述</th></tr></thead><tbody><tr><td><code>useState</code></td><td><code>ref</code> / <code>reactive</code></td><td>状态管理</td></tr><tr><td><code>useEffect</code></td><td><code>watch</code> / <code>watchEffect</code></td><td>副作用处理</td></tr><tr><td><code>useContext</code></td><td><code>provide</code> / <code>inject</code></td><td>跨组件通信</td></tr><tr><td><code>useMemo</code></td><td><code>computed</code></td><td>计算属性/缓存</td></tr><tr><td><code>useCallback</code></td><td><code>computed</code> (缓存函数)</td><td>缓存函数引用</td></tr><tr><td><code>useRef</code></td><td><code>ref</code> (非响应式)</td><td>获取DOM元素或持久化值</td></tr><tr><td><code>useLayoutEffect</code></td><td><code>onBeforeMount</code> / <code>onMounted</code></td><td>DOM更新前执行</td></tr><tr><td><code>useImperativeHandle</code></td><td><code>defineExpose</code></td><td>暴露组件方法</td></tr><tr><td><code>useDeferredValue</code></td><td><code>watchPostEffect</code></td><td>延迟更新非紧急状态</td></tr><tr><td><code>useTransition</code></td><td><code>transition</code></td><td>状态过渡效果</td></tr><tr><td><code>Suspense</code></td><td><code>Suspense</code></td><td>异步组件加载</td></tr><tr><td><code>createPortal</code></td><td><code>Teleport</code></td><td>将子组件渲染到父组件 DOM 结构之外的机制</td></tr><tr><td><code>Fragment</code></td><td><code>Fragment</code></td><td>片段组件, 多个子元素作为一个整体返回</td></tr></tbody></table>',13)]))}const g=e(r,[["render",o]]);export{x as __pageData,g as default};
